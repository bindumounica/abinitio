name: Ab Initio Style ETL ‚Äì Gated CI/CD + Scheduler

on:
  push:
    branches: [ "main" ]
    # tags:
    #   - "v*.*.*"
  workflow_dispatch:

env:
  COMPONENT_NAME: abinitio-etl-poc
  IMAGE_NAME: abinitio-etl-poc
  # VERSION: 1.0.0

# =====================================================
# DEV STAGE ‚Äì BUILD & VALIDATE
# =====================================================
jobs:
  dev:
    name: DEV ‚Äì Build & Validate
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
          cache: gradle

      - uses: actions/setup-go@v5
        with:
          go-version: "1.23.4"

      # Use the project Gradle wrapper (`./gradlew`) instead of provisioning Gradle
      # (removes intermittent HTTP 502 failures when provisioning Gradle distributions)

      - name: Derive version from Git tag
        run: |
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "VERSION=$VERSION" >> $GITHUB_ENV

      # -----------------------------
      # DEV GATE: GO MODULE HYGIENE
      # -----------------------------
      - name: Validate Go module dependencies
        run: |
          echo "[CI] Running go mod tidy (validation)"
          go mod tidy

          echo "[CI] Checking for uncommitted changes"
          if ! git diff --quiet; then
            echo "‚ùå go.mod / go.sum not tidy"
            echo "üëâ Run 'go mod tidy' locally and commit changes"
            git diff
            exit 1
          fi       

      # -----------------------------
      # DEV GATE 1: PRE-BUILD
      # -----------------------------
      - name: Pre-build validation
        run: |
          chmod +x ci/pre-build.sh
          ./ci/pre-build.sh

      - name: Build Go ETL binary
        run: |
            go mod tidy
            go build -o etl transforms/user_aggregate.go
            chmod +x etl
        

      # -----------------------------
      # DEV GATE 2: RUNTIME VALIDATION
      # -----------------------------
      - name: Run ETL pipeline (DEV validation)
        run: |
          chmod +x etl runtime/master_pipeline.sh
          # Run pipeline as the current runner user on GitHub hosted runners.
          # Creating system users requires root; avoid it in CI.
          ./runtime/master_pipeline.sh

      # -----------------------------
      # DEV GATE 3: BUILD TAR
      # -----------------------------
      - name: Build ETL TAR
        env:
          GRADLE_OPTS: "-Dscan.acceptTermsOfService=yes"
        run: |
          chmod +x gradlew
          ./gradlew build --scan --no-daemon

      - name: Upload ETL TAR artifact
        uses: actions/upload-artifact@v4
        with:
            name: etl-component-tar
            path: build/dist/*.tar        

      - name: Verify TAR
        run: |
          ls -lh build/dist
          tar -tf build/dist/*.tar

      # -----------------------------
      # DEV GATE 4: BACKWARD COMPAT
      # -----------------------------
      - name: Backward compatibility check
        run: |
          chmod +x ci/check_backward_compatibility.sh
          ./ci/check_backward_compatibility.sh

      # -----------------------------
      # DEV GATE 5: POST-BUILD
      # -----------------------------
      - name: Post-build validation
        env:
          COMPONENT_NAME: abinitio-etl-poc
          VERSION: 1.0.0
        run: |
          chmod +x ci/post-build.sh
          ./ci/post-build.sh

      # -----------------------------
      # DEV GATE 6: SONAR
      # -----------------------------

      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: ~/.gradle/caches
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle') }}
          restore-keys: ${{ runner.os }}-gradle
      - name: Run Go tests with coverage
        run: |
            go test ./transforms/... -coverprofile=coverage.out
      - name: Build, test, and analyze with SonarQube
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: ./gradlew build sonar -Dsonar.go.coverage.reportPaths=coverage.out --info

      - name: Sonar Debug Info (prints CE task + Quality Gate)
        if: always()
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          metadata=build/sonar/report-task.txt
          echo "== report-task.txt =="
          sed -n '1,120p' "$metadata" || true
          serverUrl=$(sed -n 's/serverUrl=\(.*\)/\1/p' "$metadata")
          ceTaskUrl=$(sed -n 's/ceTaskUrl=\(.*\)/\1/p' "$metadata")
          echo "CE task URL: $ceTaskUrl"
          echo "-- CE task JSON --"
          curl -s -u "${SONAR_TOKEN}:" "$ceTaskUrl" || true
          analysisId=$(curl -s -u "${SONAR_TOKEN}:" "$ceTaskUrl" | jq -r '.task.analysisId') || true
          echo "AnalysisId: $analysisId"
          echo "-- Quality Gate JSON --"
          curl -s -u "${SONAR_TOKEN}:" "${serverUrl}/api/qualitygates/project_status?analysisId=${analysisId}" || true

      - name: Sonar Quality Gate
        uses: sonarsource/sonarqube-quality-gate-action@v1.1.0
        with:
          scanMetadataReportFile: build/sonar/report-task.txt
          pollingTimeoutSec: 1200
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          
      # -----------------------------
      # DEV: BUILD & PUSH IMAGE
      # -----------------------------
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push DEV Image
        env:
          DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
            docker build \
              -t $DOCKER_USER/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-dev \
              -t $DOCKER_USER/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-sha-${{ github.sha }} \
              .
        
            docker push $DOCKER_USER/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-dev
            docker push $DOCKER_USER/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-sha-${{ github.sha }}
      - name: Trigger Harness Pipeline
        run: |
          curl -X POST \
          "https://app.harness.io/gateway/pipeline/api/v1/pipelines/${{secrets.HARNESS_PIPELINE_ID}}/execute?accountIdentifier=${{secrets.HARNESS_ACCOUNT_ID}}&orgIdentifier=${{secrets.HARNESS_ORG_ID}}&projectIdentifier=${{ secrets.HARNESS_PROJECT_ID}}" \
          -H "x-api-key: ${{ secrets.HARNESS_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{}'

# =====================================================
# UAT STAGE ‚Äì QUALITY & PROMOTION
# =====================================================
  uat:
    name: UAT ‚Äì Promote & Validate
    runs-on: ubuntu-latest
    needs: dev
    environment: uat

    steps:
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pull DEV image
        env:
            DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
            IMAGE_NAME: ${{ env.IMAGE_NAME }}
            TAG: ${{ github.ref_name }}-dev
        run: |
            docker pull "$DOCKER_USER/$IMAGE_NAME:$TAG"
        
  
      - name: UAT Smoke Test
        env:
          DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          TAG: ${{ github.ref_name }}-dev
        run: |
            docker run --rm \
              -e RUN_MODE=UAT \
                "$DOCKER_USER/$IMAGE_NAME:$TAG"
  
      - name: Promote image to UAT
        env:
          DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          TAG_DEV: ${{ github.ref_name }}-dev
          TAG_UAT: ${{ github.ref_name }}-uat
        run: |
            docker tag \
               "$DOCKER_USER/$IMAGE_NAME:$TAG_DEV"\
              "$DOCKER_USER/$IMAGE_NAME:$TAG_UAT"
  
            docker push "$DOCKER_USER/$IMAGE_NAME:$TAG_UAT"
  

# =====================================================
# PROD STAGE ‚Äì MANUAL APPROVAL + RELEASE
# =====================================================
  prod:
    name: PROD ‚Äì Manual Approval & Release
    runs-on: ubuntu-latest
    needs: uat
    environment: prod   # <-- REQUIRED REVIEWERS ENABLED HERE

    steps:
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pull UAT image
        env:
            DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
            IMAGE_NAME: ${{ env.IMAGE_NAME }}
            TAG: ${{ github.ref_name }}-uat
        run: |
            docker pull "$DOCKER_USER/$IMAGE_NAME:$TAG"
        
  
      - name: Promote image to PROD
        env:
          DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
            docker tag \
              "$DOCKER_USER/$IMAGE_NAME":${{ github.ref_name }}-uat \
              "$DOCKER_USER/$IMAGE_NAME":${{ github.ref_name }}-prod
  
            docker push "$DOCKER_USER/$IMAGE_NAME":${{ github.ref_name }}-prod
  

# =====================================================
# PROD SCHEDULED EXECUTION (OPTIONAL)
# =====================================================
  run-prod:
    name: PROD ‚Äì Scheduled ETL Execution
    runs-on: ubuntu-latest
    needs: prod
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Run ETL Component (PROD)
        env:
          DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
            docker run --rm \
              -e RUN_MODE=PROD \
              -e COMPONENT_NAME=abinitio-etl-poc \
              "$DOCKER_USER/$IMAGE_NAME":${{ github.ref_name }}-prod
  
    # schedule:
    #   - cron: '0 2 * * *'  # Runs daily at 2:00 AM UTC  